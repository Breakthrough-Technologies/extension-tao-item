TAO MATCHING API
Getting Started
%%mtime(%m/%d/%Y)

%!postproc(html): "{start_code}" '<pre class="code">'
%!postproc(html): "{end_code}" '</pre>'
%!postproc(html): "{div\|([a-zA-Z0-9-_]*)}(.*){/div}" '<div class="\1">\2</div>'
%!postproc(html): "{span\|([a-zA-Z0-9-_]*)}(.*){/span}" '<span class="\1">\2</span>'
%!encoding: utf-8
%!style   : style.css 


= Initialization =

Firstly you need to initialize the matching engine. The matching can take several parameters. Depending on these parameters the engine will be initialized in client mode or in server mode.

== Server ==

By setting the parameter **url** you will initialize the matching engine in server mode. 
And by the way provides to you a secure way to evaluate the user's responses.

{start_code}
matchingInit ({
    url         : "YOUR_MATCHING_ENGINE_REMOTE_URL"
    , params    : {}
});
{end_code}

__url__ (string) : The url of the remote matching engine

__params__ (object): You can set as many parameters as you want to the **params** attribute. These parameters will be sent to the remote matching engine. 
In TAO environment we use the **params** attribute to pass to the remote matching engine a token. 
This token will provide to the remote matching engine a manner to identify the user and its current session. 

==== Example ====

{start_code}
matchingInit ({
    url         : "http://my_tao_plateform.org/taoItems/matching/evaluate"
    , params    : {
        token   : getToken ()
    }
});
{end_code}

== Client ==

By setting the parameter **data** you will initialize a local matching engine. 
You can set some matching data directly during the initialization or later through the provided API functions.
These data will by used by the local matching engine to evaluate the user's responses.

{start_code}
matchingInit ({
    "data"    :   {
        "rule"          : ""
        , "corrects"    : []
        , "maps"        : []
        , "outcomes"    : []
        , "responses"   : []
    }
});
{end_code}

__rule__ (string) : The rule which will be used to evaluate the user's responses

__corrects__ (array) : The correct responses of the item

__maps__ (array) : The mapping responses of the items

__outcomes__ (array) : The outcomes variables of the items

__responses__ (array) : The user's responses

==== Example ====

By instance for a single choice interaction we will initialize the local matching engine as following.

{start_code}
matchingInit ({
    "data"    :   {
        "rule"          : TAO_MATCHING.RULE.MATCH_CORRECT
        , "corrects"    : [{"identifier":"RESPONSE", "value":"identifier1"}]
        , "outcomes"    : [{"identifier":"SCORE", "type":"double"}]
    }
});
{end_code}

__rule__ : Here the matching engine will evaluate the user's response with the defined template rule **TAO_MATCHING.RULE.MATCH_CORRECT**.
This template rule match the user's responses with user's responses. 

__corrects__ : Based on the given correct variable **RESPONSE** initialized with the value **identifier1**
, the rule is waiting on a user's response of type string and with single cardinality. We will see the behavior
of the template **MATCH** in this [section #MatchCorrect]

__outcomes__ : Initialization of an outcome variable identified by **SCORE** with a type double.

= Variables =

== Definition ==

Corrects, outcomes and responses follow the same format. All three are array containing variables. 
These variables are object type and they are represented as following :

{start_code}
{"identifier":VARIABLE_IDENTIFIER, "value":VARIABLE_VALUE}
{end_code}

__identifier__ (string) : Identifier of the variable

__value__ (mixed) : Value of the variable

__type__ (string) [optional] : Type of the variable (string, float, integer, tuple, list). For the known types if the value has been defined the type is found based on it.

== Value format ==

The value of a variable is represented as following :

=== Scalar types ===

__string__ : "my string"

__float__ : 3.1415

__integer__ : 123456

__boolean__ : true 

=== Container types ===

__list__ : ["val1", "val2", "val3"]

__tuple__ : {"0":"val1", "1":"val2", "2":"val3"}

=== List of containers ===

__list of list__ : [ [1,2], [3,4], [5,6] ]

__list of tuple__ : [ {"0":1, "1":2}, {"0":3, "1":4}, {"0":5, "1":6} ]

=== Tuple of containers ===

Variable creation **ok**

Matching engine support **not ok**

= Rules =

== Templates ==

=== MATCH CORRECT ===[MatchCorrect]

The match correct response processing template uses the match operator to match the value of a response 
variable RESPONSE with its correct value. It sets the outcome variable SCORE to either 0 or 1 depending 
on the outcome of the test. A response variable with called RESPONSE must have been declared and have an 
associated correct value. Similarly, the outcome variable SCORE must also have been declared. The template 
applies to responses of any baseType and cardinality though bear in mind the limitations of matching more 
complex data types.

__template code__ :

{start_code}
if (match(null, getResponse("RESPONSE"), getCorrect("RESPONSE"))){
    setOutcomeValue("SCORE", 1);
} else {
    setOutcomeValue("SCORE", 0);
}
{end_code}

=== MAP RESPONSE ===[MapResponse]

The map response processing template uses the mapResponse operator to map the value of a response variable 
RESPONSE onto a value for the outcome SCORE. Both variables must have been declared and RESPONSE must have 
an associated mapping. The template applies to responses of any baseType and cardinality.

__template code__ :

{start_code}
if(isNull(null, getResponse("RESPONSE"))) { 
    setOutcomeValue("SCORE", 0); 
} else { 
    setOutcomeValue("SCORE", mapResponse(null, getMap("RESPONSE"), getResponse("RESPONSE"))); 
}
{end_code}

== Custom Rules ==

= Examples = 

== Template Rules ==

=== Single choice interaction ===

By instance for a single choice interaction we will initialize the local matching engine as following.

{start_code}
matchingInit ({
    "data"    :   {
        "rule"          : TAO_MATCHING.RULE.MATCH_CORRECT
        , "corrects"    : [{"identifier":"RESPONSE", "value":"identifier1"}]
        , "outcomes"    : [{"identifier":"SCORE", "type":"double"}]
    }
});
{end_code}

After collected the user's responses we user the **matchingSetResponses** MatchingAPI functions to notice
the matching engine about this data.

{start_code}
matchingSetResponses ([
    {"identifier":"RESPONSE", "value":"identifier1"}
]);
{end_code}

After the user's responses passed to the matching engine you just have to fire the evaluation by calling the right method 

{start_code}
matchingEvaluate ();
{end_code}

After the evaluation of the user's response done you could get the outcome variables as following :

{start_code}
var outcomes = matchingGetOutcomes ();
console.log ('the outcome SCORE value : ' + outcomes["SCORE"]["value"]);
{end_code}

Result :
{start_code}
the value of the outcome variable SCORE is : 1
{end_code}

== Custom rules ==

=== Partial scoring with map response operator ===

Let think about a formula one racing. Where the question could be :

//The following F1 drivers finished on the podium in the first ever Grand Prix of Bahrain 2005. Can you rearrange them into the correct finishing order?//

The correct response for this interaction is a tuple of string where the drivers are well ordered. 
//DriverC// arrived in first position, //DriverB// in second position and //DriverA// in third position.
The following **tuple** variable with called **RESPONSE** represents our needs.

{start_code}
var corrects = [
    {"identifier":"RESPONSE"
    , "value" : {
        "0":"DriverC"
        , "1":"DriverB"
        , "2":"DriverA" }
    }
];
{end_code}

The outcomes required by our custom rule is a **float** with called **SCORE**

{start_code}
var outcomes = [
    {"identifier":"SCORE" , "type" : "float" }
];
{end_code}

The custom rule we defined to score the user's responses will take care about a partial scoring.
If the users will not give the exact correct response - DriverC in first position, DriverB in second position
and DriverA in third position - we will give to the user the half points.

{start_code}
var rule = 'if (match(null, getResponse("RESPONSE"), getCorrect("RESPONSE"))) {
    setOutcomeValue("SCORE", 2);
} else if (match(null, getResponse("RESPONSE"), createVariable({"type":"tuple"}, "DriverC", "DriverB", "DriverA"))) {
    setOutcomeValue ("SCORE", 1);
} else {
    setOutcomeValue("SCORE", 0);
}';
{end_code}
