function qtiShapesEditClass(canvasIdentifier){	if(!Raphael){		throw 'The raphael graphic library is required.';	}		$canvas = $('#'+canvasIdentifier);	if(!$canvas.length){		throw 'The canvas dom ellement not found.';	}		$canvas.css('border', '5px solid red');		this.canvas = Raphael(canvasIdentifier, 500, 500);	// this.shape = 'ellipse';	this.shape = 'path';	this._shapeObj = null;	this.path = [];	this.startPoint = null;	this.endPoint = null;		// var paper = Raphael("qtiCanvas", 500, 500);	// var circle = this.canvas.circle(50, 50, 40);	// var rect = this.canvas.rect(10, 10, 50, 50);		var self = this;	var canvas = this.canvas;	var _shapeObj = this._shapeObj;	// var path = this.path;		//mouse down event: init the shape:	$canvas.mousedown(function(e){		CL('mouse down');		if(self.shape){						var cursorPosition = {				x : e.pageX - this.offsetLeft,				y : e.pageY - this.offsetTop			};						if(self.shape == 'path'){				if(!self.focused){					self.focused = true;					self.removeShapeObj();					CD(self.path);					self.path = [];//reinit the path array					self.path.push(cursorPosition);				}			}else{				self.focused = true;				self.startPoint = cursorPosition;				self.removeShapeObj();			}					}	});		//mouse move event: real time update the current shape (but "path")	$canvas.mousemove(function(e){		if(self.focused && self.startPoint){			if(self.shape){								var position = {					x : e.pageX - this.offsetLeft,					y : e.pageY - this.offsetTop				};								if(canvas[self.shape]){					self.removeShapeObj();					self.setShapeObj(self.drawShape(self.startPoint, position));									}							}		}	});		//mouse up event: finishing the shap drawing (but "path")	$canvas.mouseup(function(e){		if(self.shape != 'path'){			self.focused = false;		}			});		//mouse click event: append a point to the "path" ("path" shape only)	$canvas.click(function(e){		if(self.focused && self.shape == 'path'){							var position = {				x : e.pageX - this.offsetLeft,				y : e.pageY - this.offsetTop			};						if(canvas[self.shape]){				CL('draw path!');				self.removeShapeObj();				self.setShapeObj(self.drawShape(null, position));							}					}	});		//mouse double click event: closing the path ("path" shape only)	$canvas.dblclick(function(e){		e.preventDefault();		if(self.shape == 'path'){			//close the poly shape:			if(self.path){				if(canvas[self.shape]){					self.removeShapeObj();					self.setShapeObj(self.drawShape(null, self.path[0]));				}			}						self.focused = false;		}	});			this.removeShapeObj = function(){		if(this._shapeObj){			if(this._shapeObj.remove){				this._shapeObj.remove();			}			this._shapeObj = null;		}	}		this.setShapeObj = function(shapeObj){		this._shapeObj = shapeObj;	}		this.drawShape = function(startPoint, endPoint, shape){				var returnValue = null;				if(!shape){			var shape = this.shape;		}				var shape = shape.toLowerCase();		//check if the drawing method exists:		if(this.canvas && this.canvas[shape]){			switch(shape){				case 'circle':{					var radius = Math.sqrt(Math.pow(endPoint.x-startPoint.x, 2)+Math.pow(endPoint.y-startPoint.y, 2))					returnValue = this.canvas.circle(startPoint.x, startPoint.y, radius);									break;				}				case 'rect':{					var corner = {						x: Math.min(startPoint.x, endPoint.x),						y: Math.min(startPoint.y, endPoint.y)					};										var width = Math.max(startPoint.x, endPoint.x) - corner.x;					var height = Math.max(startPoint.y, endPoint.y) - corner.y;					returnValue = this.canvas.rect(corner.x, corner.y, width, height);					break;				}				case 'ellipse':{					var horizontalRadius = Math.abs(endPoint.x - startPoint.x);					var verticalRadius = Math.abs(endPoint.y - startPoint.y);					returnValue = this.canvas.ellipse(startPoint.x, startPoint.y, horizontalRadius, verticalRadius);					break;				}				case 'path':{					var svgPath = '';										//get the previous points:					if(this.path){						this.path.push(endPoint); 												// var previousPoint = null;						for(var i=0; i<this.path.length; i++){							var currentPoint = this.path[i];														if(i==0){								svgPath += 'M'+currentPoint.x+' '+currentPoint.y;							}else{								svgPath += 'L'+currentPoint.x+' '+currentPoint.y;							}						}					}else{						throw 'no path initiated';					}										if(svgPath != ''){						returnValue = this.canvas.path(svgPath);					}					break;				}			}		}				return returnValue;	}}qtiShapesEditClass.prototype.setCurrentShape = function(shape){	this.shape = shape;}